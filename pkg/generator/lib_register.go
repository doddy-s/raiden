package generator

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"github.com/hashicorp/go-hclog"
	"github.com/sev-2/raiden/pkg/logger"
	"github.com/sev-2/raiden/pkg/utils"
)

var LibRegisterLogger hclog.Logger = logger.HcLog().Named("generator.lib_register")

// ----- Define type, variable and constant -----
type (
	GenerateLibItem struct {
		Type  string
		Alias string
	}

	GenerateLibItemData struct {
		Imports []string
		Package string
		Libs    []GenerateLibItem
	}
)

const (
	LibRegisterFilename = "libs.go"
	LibRegisterDir      = "internal/bootstrap"
	LibDir              = "internal/libs"
	LibRegisterTemplate = `// Code generated by raiden-cli; DO NOT EDIT.
package {{ .Package }}
{{if gt (len .Imports) 0 }}
import (
{{- range .Imports}}
	{{.}}
{{- end}}
)
{{end }}
func RegisterLibs(server *raiden.Server) {
	server.RegisterLibs(
		{{- range .Libs}}
			&{{.Alias}}.{{.Type}}{},
		{{- end}}
	)
}
`
)

func GenerateLibRegister(basePath string, projectName string, generateFn GenerateFn) error {
	libRegisterDir := filepath.Join(basePath, LibRegisterDir)
	LibRegisterLogger.Trace("create bootstrap folder if not exist", libRegisterDir)
	if exist := utils.IsFolderExists(libRegisterDir); !exist {
		if err := utils.CreateFolder(libRegisterDir); err != nil {
			return err
		}
	}

	libDir := filepath.Join(basePath, LibDir)
	LibRegisterLogger.Trace("create libs folder if not exist", libDir)
	if exist := utils.IsFolderExists(libDir); !exist {
		if err := utils.CreateFolder(libDir); err != nil {
			return err
		}
	}

	// scan all lib
	libList, err := WalkScanLib(libDir)
	if err != nil {
		return err
	}

	input, err := createLibRegisterInput(projectName, libRegisterDir, libList)
	if err != nil {
		return err
	}

	// setup writer
	writer := &FileWriter{FilePath: input.OutputPath}
	return generateFn(input, writer)
}

func createLibRegisterInput(projectName string, libRegisterDir string, libList []GenerateLibItem) (input GenerateInput, err error) {
	// set file path
	filePath := filepath.Join(libRegisterDir, LibRegisterFilename)

	// set imports path
	imports := []string{
		fmt.Sprintf("%q", "github.com/sev-2/raiden"),
	}
	for _, v := range libList {
		libsImportPth := fmt.Sprintf("%s/internal/libs/%s", utils.ToGoModuleName(projectName), v.Alias)
		imports = append(imports, fmt.Sprintf("%q", libsImportPth))
	}

	// set passed parameter
	data := GenerateLibItemData{
		Package: "bootstrap",
		Imports: imports,
		Libs:    libList,
	}

	input = GenerateInput{
		BindData:     data,
		Template:     LibRegisterTemplate,
		TemplateName: "libRegisterTemplate",
		OutputPath:   filePath,
	}

	return
}

func WalkScanLib(libDir string) ([]GenerateLibItem, error) {
	ModelRegisterLogger.Trace("scan registered all lib", "path", libDir)
	// Collect all subdirectories first
	libMap := make(map[string]*GenerateLibItem)
	err := scanLibDir(libDir, libMap)
	if err != nil {
		return nil, err
	}

	libs := make([]GenerateLibItem, 0, len(libMap)) // Pre-allocate capacity for performance
	for _, v := range libMap {
		libs = append(libs, *v)
	}

	return libs, nil
}

func scanLibDir(libPath string, libMap map[string]*GenerateLibItem) error {
	LibRegisterLogger.Trace("scan all controller", "path", libPath)

	entries, err := os.ReadDir(libPath)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		folderPath := fmt.Sprintf("%s/%s", libPath, entry.Name())
		err := filepath.Walk(folderPath, func(path string, info fs.FileInfo, err error) error {
			if err != nil {
				return err
			}

			if strings.HasSuffix(path, ".go") {
				rs, e := getStructByBaseName(path, "LibBase")
				if e != nil {
					return e
				}

				for _, r := range rs {
					if len(r) > 0 {
						libMap[entry.Name()] = &GenerateLibItem{Type: r, Alias: entry.Name()}
					}
				}
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return nil
}
