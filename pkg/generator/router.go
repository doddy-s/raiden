package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"unicode"

	"github.com/hashicorp/go-hclog"
	"github.com/sev-2/raiden"
	"github.com/sev-2/raiden/pkg/logger"
	"github.com/sev-2/raiden/pkg/utils"
	"github.com/valyala/fasthttp"
)

var RouterLogger hclog.Logger = logger.HcLog().Named("generator.router")

// ----- Define type, variable and constant -----
type (
	GenerateRouteItem struct {
		Import struct {
			Alias string
			Path  string
		}
		Type       string
		Path       string
		Methods    string
		Controller string
		Model      string
		Storage    string
	}

	GenerateRouterData struct {
		Imports []string
		Package string
		Routes  []GenerateRouteItem
	}

	FoundRoute struct {
		Import struct {
			Alias string
			Path  string
		}
		Package string
		Name    string
		Type    string
		Path    string
		Methods []string
		Model   string
		Storage string
	}
)

const (
	RouterFilename = "route.go"
	RouterDir      = "internal/bootstrap"
	RouterTemplate = `// Code generated by raiden-cli; DO NOT EDIT.
package {{ .Package }}
{{if gt (len .Imports) 0 }}
import (
{{- range .Imports}}
	{{.}}
{{- end}}
)
{{end }}
func RegisterRoute(server *raiden.Server) {
	server.RegisterRoute([]*raiden.Route{
		raiden.NewRouteFromController(&raiden_controllers.StateReadyController{}, []string{fasthttp.MethodPost}),
		{{- range .Routes}}
		{
			Type:       {{ .Type }},
			Path:       {{ .Path }},
			{{- if ne .Methods ""}}
			Methods:    {{ .Methods }},
			{{- end}}
			Controller: &{{ .Controller }},
			{{- if ne .Model "" }}
			Model:      {{ .Model }},
			{{- end}}
			{{- if ne .Storage "" }}
			Storage:      &{{ .Storage }},
			{{- end}}
		},
		{{- end}}
	})
}
`
)

// Generate route configuration file
func GenerateRoute(basePath string, projectName string, mode raiden.Mode, generateFn GenerateFn) error {
	routePath := filepath.Join(basePath, RouterDir)
	RouterLogger.Trace("create bootstrap folder if not exist", routePath)
	if exist := utils.IsFolderExists(routePath); !exist {
		if err := utils.CreateFolder(routePath); err != nil {
			return err
		}
	}

	controllerPath := filepath.Join(basePath, ControllerDir)

	// scan all controller
	routes, err := WalkScanControllers(mode, controllerPath)
	if err != nil {
		return err
	}

	input, err := CreateRouteInput(projectName, routePath, routes)
	if err != nil {
		return err
	}

	// setup writer
	writer := &FileWriter{FilePath: input.OutputPath}

	RouterLogger.Debug("generate route", "path", input.OutputPath)
	return generateFn(input, writer)
}

func WalkScanControllers(mode raiden.Mode, controllerPath string) ([]GenerateRouteItem, error) {
	RouterLogger.Trace("scan all controller", "path", controllerPath)

	routeMap := make(map[string]*GenerateRouteItem)
	err := scanControllerDir(mode, controllerPath, "", routeMap)
	if err != nil {
		return nil, err
	}

	routers := make([]GenerateRouteItem, 0)
	if len(routeMap) > 0 {
		for _, v := range routeMap {
			if v != nil {
				routers = append(routers, *v)
			}
		}
	}

	return routers, nil
}

func scanControllerDir(mode raiden.Mode, controllerPath, routePath string, routeMap map[string]*GenerateRouteItem) error {
	RouterLogger.Trace("scan all controller", "path", controllerPath)

	entries, err := os.ReadDir(controllerPath)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		newControllerPath := fmt.Sprintf("%s/%s", controllerPath, entry.Name())
		newRoutePath := fmt.Sprintf("%s/%s", routePath, utils.ToKebabCase(entry.Name()))
		if strings.HasPrefix(entry.Name(), "_") {
			cleanPath := utils.ToSnakeCase(entry.Name())
			newRoutePath = fmt.Sprintf("%s/{%s}", routePath, strings.TrimPrefix(cleanPath, "_"))
		}

		if entry.IsDir() {
			if err := scanControllerDir(mode, newControllerPath, newRoutePath, routeMap); err != nil {
				return err
			}
		} else {
			if strings.HasSuffix(entry.Name(), ".go") {
				fileName := strings.TrimSuffix(entry.Name(), ".go")
				filePath := fmt.Sprintf("%s/%s", controllerPath, entry.Name())
				var routers []GenerateRouteItem

				switch fileName {
				case "rest":
					restRoutes, err := getRoutes(mode, filePath, "rest", routePath)
					if err != nil {
						return err
					}
					routers = append(routers, restRoutes...)
				case "function":
					functionRoutes, err := getRoutes(mode, filePath, "function", routePath)
					if err != nil {
						return err
					}
					routers = append(routers, functionRoutes...)
				case "custom":
					customRoutes, err := getRoutes(mode, filePath, "custom", routePath)
					if err != nil {
						return err
					}
					routers = append(routers, customRoutes...)
				case "rpc":
					rpcRoutes, err := getRoutes(mode, filePath, "rpc", routePath)
					if err != nil {
						return err
					}
					routers = append(routers, rpcRoutes...)
				case "storage":
					storageRoutes, err := getRoutes(mode, filePath, "storage", routePath)
					if err != nil {
						return err
					}
					routers = append(routers, storageRoutes...)
				case "realtime":
					realtimeRoutes, err := getRoutes(mode, filePath, "realtime", routePath)
					if err != nil {
						return err
					}
					routers = append(routers, realtimeRoutes...)
				}

				if len(routers) > 0 {
					for i := range routers {
						r := routers[i]
						routeMap[r.Path] = &r
					}
				}
			}
		}
	}
	return nil
}

func getRoutes(mode raiden.Mode, controllerPath, controllerType, routePath string) (r []GenerateRouteItem, err error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, controllerPath, nil, parser.ParseComments)
	if err != nil {
		return r, err
	}

	// Traverse the AST to find the struct with the Http attribute
	foundRouteMap := make(map[string]*FoundRoute)
	ast.Inspect(file, func(node ast.Node) bool {
		switch t := node.(type) {
		case *ast.TypeSpec:
			if t.Name != nil && t.Type != nil {
				// Check if it's a struct
				if st, ok := t.Type.(*ast.StructType); ok {
					foundRoute := &FoundRoute{
						Type: controllerType,
						Path: routePath,
					}
					if fr, exist := foundRouteMap[routePath]; exist {
						foundRoute = fr
					}

					foundField := false
					for _, field := range st.Fields.List {
						if se, isSe := field.Type.(*ast.SelectorExpr); isSe && se.Sel.Name == "ControllerBase" {
							foundRoute.Name = t.Name.Name
							foundRouteMap[routePath] = foundRoute
							foundField = true
							continue
						}

						for _, fName := range field.Names {
							if fName != nil && fName.Name == "Model" {
								switch fType := field.Type.(type) {
								case *ast.StarExpr:
									if se, ok := fType.X.(*ast.SelectorExpr); ok {
										foundRoute.Model = fmt.Sprintf("%s.%s{}", se.X, se.Sel.Name)
									}
								case *ast.SelectorExpr:
									foundRoute.Model = fmt.Sprintf("%s.%s{}", fType.X, fType.Sel.Name)
								case *ast.Ident:
									foundRoute.Model = fmt.Sprintf("%s{}", fType.Name)
								}

								foundRouteMap[routePath] = foundRoute
								foundField = true
								continue
							}

							if fName != nil && fName.Name == "Storage" {
								switch fType := field.Type.(type) {
								case *ast.StarExpr:
									if se, ok := fType.X.(*ast.SelectorExpr); ok {
										foundRoute.Storage = fmt.Sprintf("%s.%s{}", se.X, se.Sel.Name)
									}
								case *ast.SelectorExpr:
									foundRoute.Storage = fmt.Sprintf("%s.%s{}", fType.X, fType.Sel.Name)
								case *ast.Ident:
									foundRoute.Storage = fmt.Sprintf("%s{}", fType.Name)
								}

								foundRouteMap[routePath] = foundRoute
								foundField = true
								continue
							}
						}
					}

					// stop walk
					if foundField {
						return foundField
					}
				}
			}
		case *ast.FuncDecl:
			if t == nil || t.Recv == nil || t.Recv.List[0].Type == nil {
				return true
			}
			startExp, isStartExp := t.Recv.List[0].Type.(*ast.StarExpr)
			if isStartExp {
				structName := fmt.Sprintf("%s", startExp.X)
				route, isExist := foundRouteMap[routePath]
				if isExist && route.Name == structName {
					switch strings.ToUpper(t.Name.Name) {
					case fasthttp.MethodGet:
						route.Methods = append(route.Methods, "fasthttp.MethodGet")
					case fasthttp.MethodPost:
						route.Methods = append(route.Methods, "fasthttp.MethodPost")
					case fasthttp.MethodPatch:
						route.Methods = append(route.Methods, "fasthttp.MethodPatch")
					case fasthttp.MethodPut:
						route.Methods = append(route.Methods, "fasthttp.MethodPut")
					case fasthttp.MethodDelete:
						route.Methods = append(route.Methods, "fasthttp.MethodDelete")
					case fasthttp.MethodOptions:
						route.Methods = append(route.Methods, "fasthttp.MethodOptions")
					case fasthttp.MethodHead:
						route.Methods = append(route.Methods, "fasthttp.MethodHead")
					}
				}
			}
		}
		return true
	})
	if len(foundRouteMap) == 0 {
		return r, nil
	}

	// bind package name
	fileDir := filepath.Dir(controllerPath)
	for _, m := range foundRouteMap {
		splitFile := strings.Split(fileDir, ControllerDir)
		if len(splitFile) == 2 {
			m.Import.Path = splitFile[1]
		}

		if len(m.Import.Path) > 0 {
			alias := utils.ToSnakeCase(
				strings.ReplaceAll(
					strings.TrimPrefix(m.Import.Path, "/"),
					"/", "_",
				),
			)
			m.Package = alias
			m.Import.Alias = alias
		} else {
			_, m.Package = filepath.Split(fileDir)
		}

	}

	for _, m := range foundRouteMap {
		rNew, err := BuildRouteItem(mode, m)
		if err != nil {
			return r, err
		}

		r = append(r, rNew)
	}

	return
}

func BuildRouteItem(mode raiden.Mode, foundRoute *FoundRoute) (GenerateRouteItem, error) {
	var r GenerateRouteItem

	r.Import = foundRoute.Import
	r.Controller = fmt.Sprintf("%s.%s{}", foundRoute.Package, foundRoute.Name)
	r.Model = foundRoute.Model
	r.Storage = foundRoute.Storage
	r.Type = foundRoute.Type
	r.Path = fmt.Sprintf("%q", foundRoute.Path)
	r.Methods = GenerateArrayDeclaration(reflect.ValueOf(foundRoute.Methods), true)

	// validate route service mode
	if mode == raiden.SvcMode && r.Type != string(raiden.RouteTypeCustom) {
		return r, fmt.Errorf("controller %s, only custom controller routes are allowed in service mode", foundRoute.Name)
	}

	// validate method
	// exclude for rest and storage controller
	// because automatically register by route
	if len(foundRoute.Methods) == 0 && r.Type != string(raiden.RouteTypeRest) && r.Type != string(raiden.RouteTypeStorage) {
		return r, fmt.Errorf("controller %s, required to set method handler. available method Get, Post, Put, Patch, Delete, and Option", foundRoute.Name)
	}

	if r.Type == string(raiden.RouteTypeRest) && r.Model == "" {
		return r, fmt.Errorf("controller %s, required to set model because have rest type", foundRoute.Name)
	}

	switch r.Type {
	case string(raiden.RouteTypeFunction):
		if len(foundRoute.Methods) > 1 {
			return r, fmt.Errorf("controller %s with type function,only allowed set 1 method and only allowed setup with post method", foundRoute.Name)
		}

		if len(foundRoute.Methods) == 1 && foundRoute.Methods[0] != "fasthttp.MethodPost" {
			return r, fmt.Errorf("controller %s with type function,only allowed setup with Post method", foundRoute.Name)
		}

		r.Type = "raiden.RouteTypeFunction"
	case string(raiden.RouteTypeCustom):
		r.Type = "raiden.RouteTypeCustom"
	case string(raiden.RouteTypeRpc):
		if len(foundRoute.Methods) > 1 {
			return r, fmt.Errorf("controller %s with type rpc,only allowed set 1 method and only allowed setup with post method", foundRoute.Name)
		}

		if len(foundRoute.Methods) == 1 && foundRoute.Methods[0] != "fasthttp.MethodPost" {
			return r, fmt.Errorf("controller %s with type rpc,only allowed setup with Post method", foundRoute.Name)
		}

		r.Type = "raiden.RouteTypeRpc"
	case string(raiden.RouteTypeRest):
		r.Type = "raiden.RouteTypeRest"
	case string(raiden.RouteTypeRealtime):
		r.Type = "raiden.RouteTypeRealtime"
	case string(raiden.RouteTypeStorage):
		r.Type = "raiden.RouteTypeStorage"
	default:
		return r, fmt.Errorf(
			"%s.%s : unsupported route type %s, available type are %s, %s, %s, %s, %s and %s ",
			foundRoute.Package, foundRoute.Name, r.Type,
			raiden.RouteTypeFunction, raiden.RouteTypeCustom, raiden.RouteTypeRpc,
			raiden.RouteTypeRest, raiden.RouteTypeRealtime, raiden.RouteTypeStorage,
		)
	}

	return r, nil
}

func CreateRouteInput(projectName string, routePath string, routes []GenerateRouteItem) (input GenerateInput, err error) {
	// set file path
	filePath := filepath.Join(routePath, RouterFilename)

	// set imports path
	imports := []string{
		fmt.Sprintf("%q", "github.com/sev-2/raiden"),
		fmt.Sprintf("%q", "github.com/valyala/fasthttp"),
		fmt.Sprintf("%s %q", "raiden_controllers", "github.com/sev-2/raiden/pkg/controllers"),
	}

	if len(routes) > 0 {
		for i := range routes {
			r := routes[i]
			if len(r.Import.Alias) > 0 && len(r.Import.Path) > 0 {
				routeImportPath := fmt.Sprintf("%s/internal/controllers%s", utils.ToGoModuleName(projectName), r.Import.Path)
				imports = append(imports, fmt.Sprintf("%s %q", r.Import.Alias, routeImportPath))
			}
		}
	}

	isHaveModel := false
	isHaveStorage := false
	for i := range routes {
		r := routes[i]

		if r.Model != "" && !isHaveModel {
			isHaveModel = true
		}

		if r.Storage != "" && !isHaveStorage {
			isHaveStorage = true
		}
	}

	if isHaveModel {
		modelImportPath := fmt.Sprintf("%s/internal/models", utils.ToGoModuleName(projectName))
		imports = append(imports, fmt.Sprintf("%q", modelImportPath))
	}

	if isHaveStorage {
		storageImportPath := fmt.Sprintf("%s/internal/storages", utils.ToGoModuleName(projectName))
		imports = append(imports, fmt.Sprintf("%q", storageImportPath))
	}

	// set passed parameter
	sort.Strings(imports)
	sort.Slice(routes, func(i, j int) bool {
		iRunes := []rune(routes[i].Path)
		jRunes := []rune(routes[j].Path)

		max := len(iRunes)
		if max > len(jRunes) {
			max = len(jRunes)
		}

		for idx := 0; idx < max; idx++ {
			ir := iRunes[idx]
			jr := jRunes[idx]

			lir := unicode.ToLower(ir)
			ljr := unicode.ToLower(jr)

			if lir != ljr {
				return lir < ljr
			}

			if ir != jr {
				return ir < jr
			}
		}

		return len(iRunes) < len(jRunes)
	})

	data := GenerateRouterData{
		Package: "bootstrap",
		Imports: imports,
		Routes:  routes,
	}

	input = GenerateInput{
		BindData:     data,
		Template:     RouterTemplate,
		TemplateName: "routerTemplate",
		OutputPath:   filePath,
	}

	return
}
